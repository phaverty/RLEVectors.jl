<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>RLEVectors · RLEVectors</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>RLEVectors</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>RLEVectors</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Implementation-Details"><span>Implementation Details</span></a></li><li><a class="tocitem" href="#split-and-tapply-like-operations"><span>split and tapply -like operations</span></a></li><li><a class="tocitem" href="#Relative-speed"><span>Relative speed</span></a></li><li><a class="tocitem" href="#Memory-considerations"><span>Memory considerations</span></a></li></ul></li><li><a class="tocitem" href="NEWS/">-</a></li><li><a class="tocitem" href="TODO/">TODO list</a></li><li><a class="tocitem" href="api/">The RLEVectors Types and Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>RLEVectors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>RLEVectors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/phaverty/RLEVectors.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RLEVectors"><a class="docs-heading-anchor" href="#RLEVectors">RLEVectors</a><a id="RLEVectors-1"></a><a class="docs-heading-anchor-permalink" href="#RLEVectors" title="Permalink"></a></h1><p><code>RLEVectors</code> is an alternate implementation of the <code>Rle</code> type from Bioconductor&#39;s IRanges package by H. Pages, P. Aboyoun and M. Lawrence. <code>RLEVectors</code> represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types are  measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations as if the vector were uncompressed.</p><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>Bioconductor has some widely used and extremely convenient types for working with collections of ranges, which sometimes are with associated data.<code>IRanges</code> represents a collection of arbitrary start, end pairs in [1,Inf). <code>GRanges</code> uses <code>IRanges</code> to represent locations on a genome and adds annotation of the chromosome and strand for each range. Children of <code>GRanges</code> add other annotations the the ranges. <code>Rle</code> represents the range [1:n] broken into arbitrary chunks or segments.</p><h2 id="Implementation-Details"><a class="docs-heading-anchor" href="#Implementation-Details">Implementation Details</a><a id="Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Details" title="Permalink"></a></h2><p><code>RLEVectors</code> differs from R&#39;s <code>Rle</code> in that we store the run values and run ends rather than the run values and run lengths. The run ends are convenient in that they allow for indexing into the vector by binary search (scalar indexing is O(log(n)) rather than O(n) ). Additionally, <code>length</code> is O(1) rather than O(n) (it&#39;s the last run end rather than the sum of the run lengths). On the other hand, various operations do require the run lengths, which have to be calculated. See the benchmark directory and reports to see how this plays out.</p><h3 id="Creation"><a class="docs-heading-anchor" href="#Creation">Creation</a><a id="Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Creation" title="Permalink"></a></h3><p><code>RLEVectors</code> can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector like a <code>Range</code> with <code>collect</code>.</p><pre><code class="language-julia hljs">using RLEVectors
x = RLEVector([1,1,2,2,3,3,4,4,4])
collect(x)
y = RLEVector([4,5,6],[3,6,9])
collect(y)</code></pre><h3 id="Describing"><a class="docs-heading-anchor" href="#Describing">Describing</a><a id="Describing-1"></a><a class="docs-heading-anchor-permalink" href="#Describing" title="Permalink"></a></h3><p><code>RLEVector</code>s implement the usual descriptive functions for an array as well as some that are specific to the type.</p><ul><li><code>length(x)</code> The full length of the vector, uncompressed</li><li><code>size(x)</code> Same as <code>length</code>, as for any other vector</li><li><code>size(x,dim)</code> Returns <code>(length(x),1) for dim == 1</code></li><li><code>starts(x)</code> The index of the beginning of each run</li><li><code>widths(x)</code> The width of each run</li><li><code>ends(x)</code> The index of the end of each run</li><li><code>values(x)</code> The data value for each run</li><li><code>isempty(x)</code> Returns boolean, as for any other vector</li><li><code>nrun(x)</code> Returns the number of runs represented in the array</li><li><code>eltype(x)</code> Returns the element type of the runs</li><li><code>endtype(x)</code> Returns the element type of the run ends</li></ul><h3 id="Standard-vector-operations"><a class="docs-heading-anchor" href="#Standard-vector-operations">Standard vector operations</a><a id="Standard-vector-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-vector-operations" title="Permalink"></a></h3><p><code>RLEVector</code>s can be treated as standard Vectors for arithmetic and collection operations. In many cases these operations are more efficient than operations on a standard vector.</p><ul><li><code>x = RLEVector([4,5,6],[3,6,9])</code></li><li><code>x[2]</code></li><li><code>x[7:9] = 10</code></li><li><code>push!(x,6)</code></li><li><code>x + 2x</code></li><li><code>unique(x)</code></li><li><code>findin(x,5)</code></li><li><code>x &gt; 4.2</code></li><li><code>sort(x)</code></li><li><code>median(x)</code></li></ul><h2 id="split-and-tapply-like-operations"><a class="docs-heading-anchor" href="#split-and-tapply-like-operations">split and tapply -like operations</a><a id="split-and-tapply-like-operations-1"></a><a class="docs-heading-anchor-permalink" href="#split-and-tapply-like-operations" title="Permalink"></a></h2><p>An RLEVector can be used like R&#39;s factor type to apply a function over (contiguous) sections of another vector. For example, here we break a vector into 5 groups and take the average of each group. In the second example, we also scale each mean by the RLE run value corresponding to each group.</p><pre><code class="language-julia hljs">factor = repeat( [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;], inner=20 )
rle = RLEVector( factor )
x = collect(1:100)
group_means = Float64[ mean(x[r]) for (v,r) in each(rle) ]</code></pre><p>This is much like the <code>tapply</code> operation in R. A convenience wrapper with this name is provided. The second, factor, argument can be an <code>RLEVector</code> or a <code>Vector</code> to be converted to an <code>RLEVector</code>. This vector need not be sorted.</p><pre><code class="language-julia hljs">tapply( x, factor, mean )
tapply( x, rle, mean )</code></pre><p>In addition to the <code>Range</code> for each RLE run, the <code>each</code> iterator provides the corresponding run value. These values can be used in calculations on each vector block.</p><pre><code class="language-julia hljs">x = collect(1:100)
rle2 = RLEVector( repeat( [1,2,3,4,5], inner=20 ) )
scaled_group_means = Float64[ v * mean(x[r]) for (v,r) in each(rle2) ]</code></pre><h2 id="Relative-speed"><a class="docs-heading-anchor" href="#Relative-speed">Relative speed</a><a id="Relative-speed-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-speed" title="Permalink"></a></h2><p><code>RLEVectors</code> has been extensively profiled and somewhat optimized. Please see the benchmarking section for the evolution over time and comparisons to like operations in R.</p><h3 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h3><p>** Please note that these benchmarks include data structure / algorithmic differences as well as language differences ** For example, indexing is O( log(n) ) in RLEVectors.jl and O(n) in the original R implementation. Similarly, <code>last</code> is a simple lookup in RLEVectors.jl where <code>width</code> is a lookup in the R version. Other functions listed here of the same computational order, but not necessarily direct translations. RLEVectors.jl is written in my interpretation of idiomatic julia.</p><p><img src="benchmark_rle_vectors.png" alt="Benchmarking results"/></p><h3 id="Optimization-progress"><a class="docs-heading-anchor" href="#Optimization-progress">Optimization progress</a><a id="Optimization-progress-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-progress" title="Permalink"></a></h3><p><img src="benchmark_rle_vectors.timeline.png" alt="Optimization progress"/></p><h2 id="Memory-considerations"><a class="docs-heading-anchor" href="#Memory-considerations">Memory considerations</a><a id="Memory-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-considerations" title="Permalink"></a></h2><p>Data compression is a secondary benefit of <code>RLEVector</code>s, but it can be convenient. Generally run ends are stored as Int64. However, if further memory savings are desired, consider smaller and unsigned types. UInt32 is sufficient to hold the length of the human genome and UInt16 can hold the length of the longest human chromosome.</p><p><code>RLEVector([5.1,2.9,100.7], UInt16[4,8,22])</code></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="NEWS/">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 13 January 2024 20:07">Saturday 13 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
