<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TODO list · RLEVectors</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RLEVectors</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">RLEVectors</a></li><li><a class="tocitem" href="../NEWS/">-</a></li><li class="is-active"><a class="tocitem" href>TODO list</a><ul class="internal"><li><a class="tocitem" href="#New-types"><span>New types</span></a></li><li><a class="tocitem" href="#.5-changes"><span>0.5 changes</span></a></li><li><a class="tocitem" href="#.6-changes"><span>0.6 changes</span></a></li><li><a class="tocitem" href="#Enhancements"><span>Enhancements</span></a></li><li><a class="tocitem" href="#Optimizations"><span>Optimizations</span></a></li><li><a class="tocitem" href="#Bugs"><span>Bugs</span></a></li><li><a class="tocitem" href="#Initial-features-for-V0.1.0"><span>Initial features for V0.1.0</span></a></li><li><a class="tocitem" href="#Decisions"><span>Decisions</span></a></li></ul></li><li><a class="tocitem" href="../api/">The RLEVectors Types and Methods</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>TODO list</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TODO list</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/phaverty/RLEVectors.jl/blob/master/docs/src/TODO.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TODO-list"><a class="docs-heading-anchor" href="#TODO-list">TODO list</a><a id="TODO-list-1"></a><a class="docs-heading-anchor-permalink" href="#TODO-list" title="Permalink"></a></h1><h2 id="New-types"><a class="docs-heading-anchor" href="#New-types">New types</a><a id="New-types-1"></a><a class="docs-heading-anchor-permalink" href="#New-types" title="Permalink"></a></h2><ul><li>[ ] Vector{RLEVector} called RLEVectorList (RVL) with group_generics that loop over elements and match elements when given two RLEs</li><li>[x] RLEDataFrame based on RLEVectorList</li><li>[ ] RVL implements all RLEVector functions as map(x,rvl)</li><li>[ ] which functions apply to the list and which map over the elements?</li><li>[ ] RLEDF needs the same creation functions as DataFrame</li></ul><h2 id=".5-changes"><a class="docs-heading-anchor" href="#.5-changes">0.5 changes</a><a id=".5-changes-1"></a><a class="docs-heading-anchor-permalink" href="#.5-changes" title="Permalink"></a></h2><ul><li>[x] Base.:(symbol) should now be Base.:symbol, requiring some changes in group_generics.jl</li><li>[x] BaseTestNext</li><li>[x] different show for MIME type for printing in REPL</li></ul><h2 id=".6-changes"><a class="docs-heading-anchor" href="#.6-changes">0.6 changes</a><a id=".6-changes-1"></a><a class="docs-heading-anchor-permalink" href="#.6-changes" title="Permalink"></a></h2><ul><li>[ ] Figure out how to write a method for broadcast</li><li>[ ] Get rid of the .+ type operators</li><li>[ ] need accumulate, maybe cumsum, cumprod</li></ul><h2 id="Enhancements"><a class="docs-heading-anchor" href="#Enhancements">Enhancements</a><a id="Enhancements-1"></a><a class="docs-heading-anchor-permalink" href="#Enhancements" title="Permalink"></a></h2><ul><li>[ ] Figure out how Documenter and doctests work together</li><li>[ ] for f in  [:sum, :prod, :mean, :var, :std] @eval mapslices(f::typeof(f), A, dims) = f(A, dims) end</li><li>[ ] Make Runs type, split from and use in RLEVector</li><li>[x] pretty <code>show</code> with elipsis if length &gt; 6, show runs and also expanded vector, use utils.rep</li><li>[x] Add benchmark/ with R and .jl scripts comparing timings on some common things. Have one read a CSV from the other and plot.</li><li>[ ] outer constructor for RLEVectors that takes runends or vector and then optional named args runends and runwidths</li><li>[ ] Can I make a special zip-like loop that runs over the disjoint runs of 2+ RLEVectors and the associated values?</li><li>[ ] vcat with splat for multiple args (vararg vcat)</li><li>[x] deleterun! should give a ree&#39;d RLEVector, check for newly adjacent runs, use deleteat![x,itr] if necessary</li><li>[x] Any other function groups from DataArrays that I need?</li><li>[x] factor out run counting stuff in ree(Vector) and disjoin, call it <code>nrun</code></li><li>[x] implement comparison operators &lt;=, etc.</li><li>[x] Rle to set conversion</li><li>[ ] iterator versions of rwidth and rstart. Allocation is the root of all evil. Allocation in rwidth seems to be the bulk of &#39;median&#39; at this point, for example.</li><li>[x] ind2runcontext for UnitRange, use for setindex(x::RLEVector, value, indices::UnitRange)</li><li>[x] Make sure this works with Julia V0.4. Likely we have some tuple trouble and the tests will be riddled with the Range expansion change ([1:4] is a 1-vector of Ranges rather than [1,2,3,4]).</li><li>[x] function documentation section: describing</li><li>[x] function documentation section: creating</li><li>[x] function documentation section: range functions</li><li>[ ] get ree and vcat out of splice</li><li>[ ] iterator called &#39;ranges&#39; that gives (first,last) indices for runs. Will require a new type with the 3 iterator methods, say RLERangesIterator.</li><li>[x] Make sure my hash and == are what AutoHashEquals would say</li><li>[ ] linalg operations</li><li>[ ] make &#39;each&#39; a Task?</li><li>[ ] make disjoin Task for two RLEs?</li><li>[ ] faster group_generic operations based on disjoin</li><li>[ ] Some way to disjoin two RLEs such that the runends are made identical, with some repeated runvalues (necessarily). Should it be OK have an RLE be less than fully compressed? Would &#39;ree&#39; then re-compress it?</li><li>[x] test for ind2run(rle::RLEVector, i::AbstractArray)</li><li>[x] new testing framework with nice reports</li><li>[x] Setup Documenter.jl - based docs pushed to github by travis</li><li>[x] add stable docs badge after next version bump</li><li>[ ] in-place ree!(runs,lengths) as a step towards immutable RLEVector</li></ul><h2 id="Optimizations"><a class="docs-heading-anchor" href="#Optimizations">Optimizations</a><a id="Optimizations-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizations" title="Permalink"></a></h2><ul><li>[ ] Re-read julia/base/range.jl, some day understand the meaning of &quot;# to make StepRange constructor inlineable, so optimizer can see <code>step</code> value&quot;</li><li>[x] getindex and setindex! optimizations for sorted i, especially for i::UnitRange</li><li>[ ] Lint clean and test for that</li><li>[ ] TypeCheck clean (and test for that?)</li><li>[ ] some trick with start(Range) to make splice! work with scalar int or range</li><li>[ ] revisit all the array surgery functions like splice!, factor out common elements, try to use resize and copy. Try to centralize the merging of two things, checking for shared runvalues at the ends.</li><li>[x] try optimizing rwidth and rfirst by copying x.runends and then modifying the copy in place</li><li>[x] much faster rwidth and rfirst</li><li>[x] get vcat and sort out of disjoin, especially sort</li><li>[ ] Everything seems to have a special case for length &lt; 2 Rles. Is there some way to make those unnecessary globally?</li><li>[x] custom O(n) disjoin</li><li>[x] ree, bottleneck is making the return tuple. Do ree! and update an Rle?</li><li>[x] use sort for median rather than collect, use i = fld(n,2) + 1 for odd n ...</li><li>[x] look for places where I can use isempty instead of length. 2X speed of nrun(x) == 0 and 4X speed of length(x) == 0</li><li>[x] findmin</li><li>[x] findmax</li><li>[x] findin</li><li>[x] indexin</li><li>[ ] can I do setindex(x::Rlevector, i, indices::Array) and such with an iterator that feeds &quot;ree&quot;?  Sort incoming indices and values of course.</li><li>[x] add a few special cases to the &quot;punt else&quot; to work towards not punting</li><li>[ ] setindex!(rle::RLEVector, value, i::UnitRange), can I merge this with the scalar i case using i:i?</li><li>[x] Inherit from AbstractVector so I can get all the new free AbstractVector indexing</li><li>[ ] Should logical indexing become indexing with an array of Ranges?</li><li>[ ] implement Selection algorithm for median: https://en.wikipedia.org/wiki/Selection_algorithm</li><li>[ ] while true break for ree and numruns?</li><li>[x] rle + rle spends all its time doing ind2run </li><li>[x] Do disjoin from 1 towards n so that we can use resize! to shrink and account for shorter length due to ties rather than using disjoin_length.</li><li>[x] More tests for similar using 2 or 3 args</li><li>[x] Add badges to README</li><li>[x] Codecov.io</li><li>[x] getindex x[i,j] on RLEDT has an extra copies the j columns unnecessarily</li></ul><h2 id="Bugs"><a class="docs-heading-anchor" href="#Bugs">Bugs</a><a id="Bugs-1"></a><a class="docs-heading-anchor-permalink" href="#Bugs" title="Permalink"></a></h2><ul><li>[x] fix mode, needs to do table not just which.max</li><li>[x] fix vcat, what about merging adjacent runs?</li><li>[x] binary_functions list not all commutative, split up, mabye set operations separately</li><li>[x] changes to ree cause reversions in insert and splice</li><li>[x] Fix group generics definitions to get rid of ambiguous method warnings</li><li>[x] something is wrong with the iterator, which breaks sum and mean</li><li>[x] something in splice and insert</li><li>[x] ree(runvalues,runends) needs to avoid modifying input</li><li>[x] do I need a print_matrix method to make auto-printing work? print and show work fine.</li><li>[x] Do I need Base.linearindexing{T&lt;:MyArray}(::Type{T}) = LinearFast() </li><li>[x] median with an Int RLE is type unstable, div by 2 gives float otherwise Int</li><li>[x] setindex!(rle, 801:900, 1:100) does setindex!(rle::RLEVector, value, indices::UnitRange) rather than looking for a two vector method</li><li>[x] It seems that one cannot make a vector of RLEVectors</li><li>[x] intersect should maintain multiplicity of 1st arg</li><li>[x] new disjoin-based group ops does not work for .&lt; and friends as it does scalar ops inside a loop</li><li>[ ] findin and findmax seem to have type stability problems</li><li>[x] rfirst(x,i) also has type stability issues</li><li>[ ] Should RLEVector() have a runvalue of [0] or []?  It is the former at the moment.</li></ul><h2 id="Initial-features-for-V0.1.0"><a class="docs-heading-anchor" href="#Initial-features-for-V0.1.0">Initial features for V0.1.0</a><a id="Initial-features-for-V0.1.0-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-features-for-V0.1.0" title="Permalink"></a></h2><ul><li>[x] Examples in toplevel README</li><li>[x] Some bleeping unit tests already!  It&#39;s time.</li><li>[x] Test for types</li><li>[x] Test for collections</li><li>[x] Test for indexing</li><li>[x] Test for describe</li><li>[x] Test for math</li><li>[x] Tests for utils</li><li>[x] Split RLEVectors.jl into multiple files by subject. It&#39;s getting unweildy.</li><li>[x] conversion of RLEVector{T} to Vector{T}</li><li>[x] runind or findRun or whichRun method, return index or (index,offset)</li><li>[x] how does julia do R&#39;s table? R&#39;s S4vectors doesn&#39;t do table(rle1,rle2), but wants to</li><li>[x] Set operations like setdiff, union, symdiff</li><li>[x] rle method on Rle, drop zero length runs and join runs with same value</li><li>[x] clarity on zero-length runs. OK? start and end == 1? What would value be (would I need to get myself involved with DataArrays and Nullable do do this?)</li><li>[x] in initializer check incoming runends are sorted</li><li>[x] initializer checks incoming runends are stricly increasing, would be nice to use issorted with a new comparator</li><li>[x] rep utility to match R&#39;s</li><li>[x] more vector funs: head, tail</li><li>[x] getindex and setindex! for i::AbstractArray</li><li>[x] deleteat!</li><li>[x] splice!</li><li>[x] inverse_rle method for RLEVector, use in collect etc., skip rwidth</li><li>[x] fix setindex when on end of run, check for zero length run</li><li>[x] resize!</li><li>[x] constructor that takes bitarray and converts to bool array: convert(Vector{Int32},bob)</li><li>[x] sorting including sort, issorted, reverse and sortperm</li></ul><h2 id="Decisions"><a class="docs-heading-anchor" href="#Decisions">Decisions</a><a id="Decisions-1"></a><a class="docs-heading-anchor-permalink" href="#Decisions" title="Permalink"></a></h2><ul><li><p>[x] Decide when getindex gives an Vector or an RLEVector, be consistent</p></li><li><p>[x] How do I set up the type hierarchy?  a.  How do I share common code as high in the tree as possible? (wait for new features of abstract types in 0.4?)  b.  Can I make it a subtype of Vector and get lots of the Vector  API for free?  Can I then use it in other places that take a  vector? Like a DataFrame column?</p></li><li><p>[x] How do I represent the runs? length, end, start/end?</p><p>end allows for direct binarysearch for indexing and makes size a simple lookup   Gives 5X speedup for size, 40X for indexing on RLEVector(int([1:1:1e3]),int([1:1:1e3]))   19956X speedup over R (more efficient algo here though) for     foo = Rle( seq(1,1000,5), rep.int(5,200) )     l = 1:1e3; system.time( for(i in l) { foo[100] } )       vs.     foo = IntegerRle([ int(linspace(1,1000,200)) ], [ int(linspace(1,1000,200)) ])     @time for i in 1:1e3 foo[100] end     2000X speedup for foo + 4</p></li><li><p>[x] Is there a strictly increasing and positive int vector type I can leverage or make for the runs?      Maybe something that could be linked to the values?  OrderedSet, IntSet?      For disjoin operations, it will be useful to know the unique runends in two+ sets of runs      Would be nice to have disjoin for RLEVector and RunEnds and IRanges and GRanges types</p></li><li><p>[x] What do I call the getters and setters? I want to use same getters for RLEs and GRanges and such.   begin, end and start are taken. first, step, and last make sense because of what they mean for ranges, but they would mean something else for a Vector   Maybe confusion between Ranges and Vector API means that I should just make my own and use rangestart, rangewidth, rangeend or rfirst, rwidth and rlast. With the latter, the &#39;r&#39; could be range or run.</p></li></ul><pre><code class="nohighlight hljs">Maybe starts, widths, ends?</code></pre><ul><li><p>[x] Is it a good idea to require two arg vectors to be the same length like this: function bob{T1,T1,N}(x::Vector{T1,N},y::Vector{T2,N})  ?  Or just test the lengths and throw an ArgumentError?</p></li><li><p>[ ] <code>each</code> should probably be <code>eachrange</code></p></li><li><p>[x] Is 1 an appropriate start for an empty RLEVector? Does that imply that there is a value associated? Go to zero-based, half open (#can-of-worms)?. NO.</p></li><li><p>[x] does one export methods defined on generics from Base?</p></li><li><p>[x] similar. What would length arg do?  length, nrun, always return an empty one?</p></li><li><p>[x] better naming for runindex, ind2run</p></li><li><p>[x] maybe drop ree!(x::RLEVector) for a ree that returns a tuple of cleaned up runvalues and runends? With the new 0.4 tuple hotness performance won&#39;t matter anymore (right?)</p></li><li><p>[x] when incoming runvalues for RLEVector creation is a BitArray (like from .&lt;) where do I unpack it? Probably best during ree, because it will probably get shorter. Use numruns(runvalues) then deal with 0-len runs separately?</p></li><li><p>[x] What type to return for a slice of an RLEVector?</p></li><li><p>[x] likewise, maybe ind2range(RLEVector, UnitRange) should return a UnitRange</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../NEWS/">« -</a><a class="docs-footer-nextpage" href="../api/">The RLEVectors Types and Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 13 January 2024 20:07">Saturday 13 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
